import 'mocha';
import { expect } from 'chai';
import path from 'path';
import { emit } from '@rsql/emitter';
import {
  TestContext, TestUtils,
} from '@internal/tools/src';
import { 
  TestLogger,
  EpSdkRsqlQueryBuilder,
} from '../lib';
import {
  ApiError, 
  ApplicationRegistrationResponse, 
  ApplicationRegistrationsResponse, 
  ApplicationRegistrationView, 
  Credentials, 
  EventApiProduct, 
  EventApiProductRegistrationResponse, 
  EventApiProductsResponse, 
  EventApiProductsService, 
  Plan, 
  RegistrationsService,
} from '../../generated-src';

const scriptName: string = path.basename(__filename);
TestLogger.logMessage(scriptName, ">>> starting ...");

// pre-defined in EP
const ApplicationDomainName = "TEST_APIM_API";
const ApplicationDomainId = "gb2ila1uhoj";

const ConsumerAppSource = "ep-devp-showcase";
const ConsumerAppAnotherSource = 'another-dev-portal';
const NumberOfConsumerApps = 10;
const generateConsumerAppName = (rootName: string, i:number) => {
  return `${rootName}-${i}`;
}
const ConsumerAppIds: Map<string, string> = new Map<string, string>();

let AutoGeneratedCredentialsConsumerKey: string | undefined;
let ConsumerCreatedCredentialSet_1: Credentials = {
  name: "ConsumerCreatedCredentialSet_1",
  // expiresAt: -1,
  secret: {
    consumerKey: "consumerKey",
    consumerSecret: "consumerSecret"
  }
}
let ConsumerCreatedCredentialSet_2: Credentials = {
  name: "ConsumerCreatedCredentialSet_2",
  // expiresAt: -1,
}

const EventApiProductName_1 = "EventApiProduct_1";
let EventApiProduct_1: EventApiProduct;


const initializeGlobals = () => {
  // initialize parameterized globals
};

describe(`${scriptName}`, () => {
    
  before(async () => {
    TestContext.newItId();
    initializeGlobals();
  });

  beforeEach(() => {
    TestContext.newItId();
  });


  it(`${scriptName}: should create all consumer apps`, async () => {
    try {
      for(let i=0; i<NumberOfConsumerApps; i++) {
        const consumerAppName = generateConsumerAppName(`ep-devp-consumer-app @ ${ConsumerAppSource}`,i);
        const applicationRegistrationResponse: ApplicationRegistrationResponse = await RegistrationsService.createAppRegistration({
          xContextId: 'xContextId',
          requestBody: {
            name: consumerAppName,
            registrationId: TestUtils.getShortUUID(),
            source: ConsumerAppSource,
            applicationDomainId: ApplicationDomainId,
          }
        });
        ConsumerAppIds.set(consumerAppName, applicationRegistrationResponse.data.registrationId);
      }
    } catch(e) {
      expect(e instanceof ApiError, TestLogger.createNotApiErrorMessage(e.message)).to.be.true;
      expect(false, TestLogger.createApiTestFailMessage('failed', e)).to.be.true;
    }
  });

  it(`${scriptName}: should request access to eventApiProduct with plan`, async () => {    
    try {
      // select EventApiProduct
      const queryAst = EpSdkRsqlQueryBuilder.eq(TestUtils.nameOf<EventApiProduct>("name"), EventApiProductName_1);
      const eventApiProductsResponse: EventApiProductsResponse = await EventApiProductsService.listEventApiProducts({
        xContextId: 'xContextId',

        query: emit(queryAst)
      });
      expect(eventApiProductsResponse.data.length, 'eventApiProductsResponse.data.length').to.equal(1);
      EventApiProduct_1 = eventApiProductsResponse.data[0];
      // // DEBUG
      // expect(false,TestLogger.createLogMessage('DEBUG: eventApiProductsResponse.data', eventApiProductsResponse.data)).to.be.true;
      expect(EventApiProduct_1.plans.length, 'EventApiProduct_1.plans.length').to.be.greaterThanOrEqual(2);
      // create the access request plan 0
      const plan_0: Plan = EventApiProduct_1.plans[0];
      for(const [name, id] of ConsumerAppIds) {
        const eventApiProductRegistrationResponse: EventApiProductRegistrationResponse = await RegistrationsService.createAppRegistrationAccessRequest({
          xContextId: 'xContextId',
          registrationId: id,
          requestBody: {
            accessRequestId: TestUtils.getShortUUID(),
            eventApiProductId: EventApiProduct_1.id,
            planId: plan_0.id,
            registrationId: id
          }
        });  
      }
    } catch(e) {
      expect(e instanceof ApiError, TestLogger.createNotApiErrorMessage(e.message)).to.be.true;
      expect(false, TestLogger.createApiTestFailMessage('failed', e)).to.be.true;
    }
  });

  it(`${scriptName}: should create consumer apps with different source`, async () => {
    try {
      for(let i=0; i<NumberOfConsumerApps; i++) {
        const consumerAppName = generateConsumerAppName(`ep-devp-consumer-app @ ${ConsumerAppAnotherSource}`,i);
        const applicationRegistrationResponse: ApplicationRegistrationResponse = await RegistrationsService.createAppRegistration({
          xContextId: 'xContextId',
          requestBody: {
            name: consumerAppName,
            registrationId: TestUtils.getShortUUID(),
            source: ConsumerAppAnotherSource,
            applicationDomainId: ApplicationDomainId,
          }
        });
        ConsumerAppIds.set(consumerAppName, applicationRegistrationResponse.data.registrationId);
      }
    } catch(e) {
      expect(e instanceof ApiError, TestLogger.createNotApiErrorMessage(e.message)).to.be.true;
      expect(false, TestLogger.createApiTestFailMessage('failed', e)).to.be.true;
    }
  });

  it(`${scriptName}: should list consumer apps filtered by source`, async () => {
    try {
      const sourceQueryAst = EpSdkRsqlQueryBuilder.eq(TestUtils.nameOf<ApplicationRegistrationView>('source'), ConsumerAppSource);
      const applicationRegistrationsResponse: ApplicationRegistrationsResponse = await RegistrationsService.listAppRegistrations({ 
        xContextId: 'xContextId',
        query: emit(sourceQueryAst),
        pageSize: 100
      });
      expect(applicationRegistrationsResponse.data.length, TestLogger.createApiTestFailMessage(`received ${applicationRegistrationsResponse.data.length} applicationRegistrations`)).to.equal(NumberOfConsumerApps);
    } catch(e) {
      expect(e instanceof ApiError, TestLogger.createNotApiErrorMessage(e.message)).to.be.true;
      expect(false, TestLogger.createApiTestFailMessage('failed', e)).to.be.true;
    }
  });

});

